"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
const pegjs_1 = __importDefault(require("pegjs"));
const conversions_1 = __importDefault(require("./helpers/conversions"));
var LOGIC_OPERATOR;
(function (LOGIC_OPERATOR) {
    LOGIC_OPERATOR["AND"] = "AND";
    LOGIC_OPERATOR["OR"] = "OR";
})(LOGIC_OPERATOR = exports.LOGIC_OPERATOR || (exports.LOGIC_OPERATOR = {}));
var UNKNOWN_REASONS;
(function (UNKNOWN_REASONS) {
    UNKNOWN_REASONS["PARSING"] = "mismatch during parsing";
    UNKNOWN_REASONS["PARSING_AMOUNT"] = "unknown amount";
    UNKNOWN_REASONS["PARSING_UNIT"] = "unknown unit";
    UNKNOWN_REASONS["NO_ENTRY"] = "unavailable ingredient";
})(UNKNOWN_REASONS = exports.UNKNOWN_REASONS || (exports.UNKNOWN_REASONS = {}));
class RecipesParser {
    constructor(rules, units, globalUnit) {
        this.rules = rules;
        this.units = units;
        this.globalUnit = globalUnit;
        this.nlpParser = pegjs_1.default.generate(this.rules);
        this.conversionsUtils = new conversions_1.default(this.units, this.globalUnit);
    }
    getIngredientsFromText(recipeInstructions, returnUnitKey) {
        const output = {
            unknown: {},
        };
        // Parse and normalize the ingredients
        return lodash_1.default.map(recipeInstructions, (instruction) => {
            const recipeStr = instruction
                .replace("½", "1/2")
                .replace("⅓", "1/3")
                .replace("¼", "1/4")
                .replace("¾", "3/4")
                .replace("⅔", "2/3");
            const parts = this.nlpParser.parse(recipeStr);
            if (typeof parts.amount === "undefined" ||
                typeof parts.ingredient === "undefined") {
                const unknownReasons = [UNKNOWN_REASONS.PARSING];
                if (!parts.amount) {
                    unknownReasons.push(UNKNOWN_REASONS.PARSING_AMOUNT);
                }
                output.unknown = {
                    instruction,
                    reasons: unknownReasons,
                };
                return output;
            }
            else {
                parts.amount = this.conversionsUtils.normalizeAmount(parts.amount);
                // get unit key match
                if (returnUnitKey) {
                    parts.unit = this.conversionsUtils.getUnitKey(parts.unit);
                }
                output.result = {
                    instruction,
                    unit: parts.unit,
                    amount: parts.amount,
                    ingredient: parts.ingredient,
                };
                return output;
            }
        });
    }
}
exports.default = RecipesParser;
